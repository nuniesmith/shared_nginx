name: ðŸš€ Streamlined Service Deployment

# Simplified workflow that leverages scripts for all heavy lifting
# Follows stage0 (GitHub runner) -> stage1 (Arch setup) -> stage2 (systemd ready) pattern

on:
  workflow_call:
    inputs:
      service_name:
        description: 'Service to deploy (fks, nginx, ats, etc.)'
        required: true
        type: string
      source_repository:
        description: 'Source repository name (defaults to service_name)'
        required: false
        type: string
      action_type:
        description: 'Action: deploy, destroy, health-check, restart'
        required: false
        type: string
        default: 'deploy'
      server_type:
        description: 'Linode server type'
        required: false
        type: string
        default: 'g6-nanode-1'
      target_region:
        description: 'Linode region'
        required: false
        type: string
        default: 'us-central'
      domain_suffix:
        description: 'Domain suffix'
        required: false
        type: string
        default: '7gram.xyz'
      custom_domain:
        description: 'Override full domain (e.g., api.fkstrading.xyz)'
        required: false
        type: string
      overwrite_server:
        description: 'Destroy and recreate server'
        required: false
        type: boolean
        default: false
      deployment_mode:
        description: 'Deployment mode: single (default), multi (matrix), or home (static servers)'
        required: false
        type: string
        default: 'single'
      instance_matrix:
        description: 'JSON array of instance names for multi mode, e.g. ["api","web","auth"]'
        required: false
        type: string
        default: '[]'
      home_target_host:
        description: 'Host to SSH for home mode (hostname or IP)'
        required: false
        type: string
      home_service_user:
        description: 'Service user on home server (e.g., freddy_user)'
        required: false
        type: string
      home_repo_url:
        description: 'Repo URL for home deploy (defaults to https://github.com/nuniesmith/<service>.git)'
        required: false
        type: string
      jump_host:
        description: 'Optional SSH jump host for home deployments (e.g., nginx.7gram.xyz)'
        required: false
        type: string
    
    secrets:
      LINODE_CLI_TOKEN:
        required: true
      SERVICE_ROOT_PASSWORD:
        required: true
      ACTIONS_USER_PASSWORD:
        required: true
      JORDAN_PASSWORD:
        required: true
      TS_OAUTH_CLIENT_ID:
        required: true
      TS_OAUTH_SECRET:
        required: true
      TAILSCALE_TAILNET:
        required: true
      CLOUDFLARE_API_TOKEN:
        required: true
      CLOUDFLARE_ZONE_ID:
        required: true
      ADMIN_EMAIL:
        required: true
      # Enhanced Security and Configuration Secrets
      SERVICE_USER_PASSWORD:
        required: false
      SSL_STAGING:
        required: false
      AUTHENTIK_JWT_SECRET:
        required: false
      JWT_SECRET_KEY:
        required: false
      NGINX_AUTH_USER:
        required: false
      NGINX_AUTH_PASS:
        required: false
      DISCORD_WEBHOOK_URL:
        required: false
      DOCKER_TOKEN:
        required: false
      DOCKER_USERNAME:
        required: false
      FULLY_QUALIFIED_DOMAIN_NAME:
        required: false
      TOP_LEVEL_DOMAIN:
        required: false
      NETDATA_CLAIM_ROOM:
        required: false
      NETDATA_CLAIM_TOKEN:
        required: false
      # SSH Public Keys for authorized access
      DESKTOP_SSH_PUB:
        required: false
      FREDDY_SSH_PUB:
        required: false
      MACBOOK_SSH_PUB:
        required: false
      ORYX_SSH_PUB:
        required: false
      SULLIVAN_SSH_PUB:
        required: false
      SSH_PRIVATE_KEY:
        required: false
      HOME_ROOT_SSH_KEY:
        required: false

    outputs:
      server_id:
        value: ${{ jobs.infrastructure.outputs.server_id }}
      server_ip:
        value: ${{ jobs.infrastructure.outputs.server_ip }}
      tailscale_ip:
        value: ${{ jobs.infrastructure.outputs.tailscale_ip }}
      deployment_status:
        value: ${{ jobs.infrastructure.outputs.deployment_status }}
      restart_status:
        value: ${{ jobs.service-restart.outputs.status }}
      destruction_status:
        value: ${{ jobs.service-destroy.outputs.status }}

env:
  SERVICE_NAME: ${{ inputs.service_name }}
  SOURCE_REPOSITORY: ${{ inputs.source_repository || inputs.service_name }}
  ACTION_TYPE: ${{ inputs.action_type }}
  FULL_DOMAIN: ${{ inputs.custom_domain || format('{0}.{1}', inputs.service_name, inputs.domain_suffix) }}

jobs:
  stage0-preflight:
    name: ðŸš¦ Stage 0 - Preflight Checks
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.stage0.outputs.should_deploy }}
      should_destroy: ${{ steps.stage0.outputs.should_destroy }}
      should_health_check: ${{ steps.stage0.outputs.should_health_check }}
      should_overwrite_server: ${{ steps.stage0.outputs.should_overwrite_server }}
      destroy_confirmed: ${{ steps.stage0.outputs.destroy_confirmed }}
      docker_build_needed: ${{ steps.stage0.outputs.docker_build_needed }}
      secrets_validated: ${{ steps.stage0.outputs.secrets_validated }}
      stage0_complete: ${{ steps.stage0.outputs.stage0_complete }}
    steps:
      - name: âœ… Run Stage 0 - Preflight Checks
        id: stage0
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          SERVICE_ROOT_PASSWORD: ${{ secrets.SERVICE_ROOT_PASSWORD }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
        run: |
          set -euo pipefail
          echo "stage0_complete=true" >> $GITHUB_OUTPUT
          echo "should_deploy=true" >> $GITHUB_OUTPUT
          echo "should_destroy=false" >> $GITHUB_OUTPUT
          echo "should_health_check=false" >> $GITHUB_OUTPUT
          echo "should_overwrite_server=${{ inputs.overwrite_server }}" >> $GITHUB_OUTPUT
          echo "destroy_confirmed=false" >> $GITHUB_OUTPUT
          echo "docker_build_needed=false" >> $GITHUB_OUTPUT
          echo "secrets_validated=true" >> $GITHUB_OUTPUT

  infrastructure:
    name: ðŸ—ï¸ Stage 1 - Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: [stage0-preflight]
    if: needs.stage0-preflight.outputs.should_deploy == 'true' && inputs.deployment_mode != 'multi' && inputs.deployment_mode != 'home'
    outputs:
      server_id: ${{ steps.linode.outputs.server_id }}
      server_ip: ${{ steps.linode.outputs.server_ip }}
      tailscale_ip: ${{ steps.linode.outputs.tailscale_ip }}
      deployment_status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: ðŸ“ Checkout Actions Repo (scripts)
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      - name: ðŸ©¹ Patch Linode create-server script (authorized_keys format)
        run: |
          set -euo pipefail
          FILE=./scripts/linode/create-server.sh
          if grep -q "SSH_PUBLIC_KEY=$(base64 -w 0 ~/.ssh/linode_deployment_key.pub)" "$FILE"; then
            sed -i 's#SSH_PUBLIC_KEY=$(base64 -w 0 ~/.ssh/linode_deployment_key.pub)#SSH_PUBLIC_KEY=$(cat ~/.ssh/linode_deployment_key.pub | tr -d "\\n")#' "$FILE"
            echo "âœ… Patched create-server.sh to use raw SSH public key for Linode authorized_keys"
          else
            sed -i 's#base64 -w 0 ~/.ssh/linode_deployment_key\.pub#cat ~/.ssh/linode_deployment_key.pub | tr -d "\\n"#' "$FILE" || true
            echo "â„¹ï¸ Applied generic patch for SSH public key extraction (raw)"
          fi
      - name: ðŸ—ï¸ Create Server
        id: linode
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          SERVICE_ROOT_PASSWORD: ${{ secrets.SERVICE_ROOT_PASSWORD }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
        run: |
          chmod +x ./scripts/linode/create-server.sh
          ./scripts/linode/create-server.sh \
            "${{ env.SERVICE_NAME }}" \
            "${{ inputs.server_type }}" \
            "${{ inputs.target_region }}" \
            "${{ inputs.overwrite_server }}"
      - name: â³ Wait for SSH Access
        if: steps.linode.outputs.server_ip != 'EXTRACTION_FAILED' && steps.linode.outputs.server_ip != ''
        run: |
          echo "â³ Waiting for SSH access to ${{ steps.linode.outputs.server_ip }} using helper script..."
          chmod +x ./scripts/linode/wait-for-ssh.sh
          ./scripts/linode/wait-for-ssh.sh "${{ steps.linode.outputs.server_ip }}"
      - name: ðŸ“¦ Upload SSH deployment key (artifact)
        if: steps.linode.outputs.server_ip != 'EXTRACTION_FAILED' && steps.linode.outputs.server_ip != ''
        uses: actions/upload-artifact@v4
        with:
          name: deployment_key
          path: ~/.ssh/linode_deployment_key
          if-no-files-found: error
      - name: ðŸ”§ Run Stage 1, prepare Stage 2, reboot, then deploy
        id: deploy
        if: steps.linode.outputs.server_ip != 'EXTRACTION_FAILED' && steps.linode.outputs.server_ip != ''
        env:
          SERVER_IP: ${{ steps.linode.outputs.server_ip }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
          SERVICE_USER_PASSWORD: ${{ secrets.SERVICE_USER_PASSWORD }}
          SSL_STAGING: ${{ secrets.SSL_STAGING }}
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
        run: |
          set -euo pipefail
          echo "ðŸ”§ Running Stage 1 setup and preparing Stage 2 on server..."
          SVC_NAME="$SERVICE_NAME"
          SVC_SERVER_IP="$SERVER_IP"
          
          # Prepare Stage 1 script with placeholders replaced
          cp ./scripts/stage1-complete-setup.sh /tmp/stage1-setup.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/${SVC_NAME}/g" /tmp/stage1-setup.sh
          sed -i "s/ACTIONS_USER_PASSWORD_PLACEHOLDER/${ACTIONS_USER_PASSWORD}/g" /tmp/stage1-setup.sh
          sed -i "s/JORDAN_PASSWORD_PLACEHOLDER/${JORDAN_PASSWORD}/g" /tmp/stage1-setup.sh
          sed -i "s/SERVICE_USER_PASSWORD_PLACEHOLDER/${SERVICE_USER_PASSWORD}/g" /tmp/stage1-setup.sh
          sed -i "s/SSL_STAGING_PLACEHOLDER/${SSL_STAGING}/g" /tmp/stage1-setup.sh

          # Prepare Stage 2 script and env file
          cp ./scripts/stage2-post-reboot.sh /tmp/stage2-post-reboot.sh
          chmod +x /tmp/stage2-post-reboot.sh
          {
            printf "TS_OAUTH_CLIENT_ID_ENV='%s'\n" "$TS_OAUTH_CLIENT_ID"
            printf "TS_OAUTH_SECRET_ENV='%s'\n" "$TS_OAUTH_SECRET"
            printf "SERVICE_NAME_ENV='%s'\n" "$SVC_NAME"
            printf "DOMAIN_NAME_ENV='%s'\n" "$FULL_DOMAIN"
            printf "CLOUDFLARE_EMAIL_ENV='%s'\n" ""
            printf "CLOUDFLARE_API_TOKEN_ENV='%s'\n" "$CLOUDFLARE_API_TOKEN"
            printf "ADMIN_EMAIL_ENV='%s'\n" "$ADMIN_EMAIL"
          } > /tmp/stage2-env.sh

          echo "ðŸ“¤ Uploading Stage 1/2 assets to server..."
          scp -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no /tmp/stage1-setup.sh root@"$SVC_SERVER_IP":/root/stage1-setup.sh
          scp -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no /tmp/stage2-post-reboot.sh root@"$SVC_SERVER_IP":/usr/local/bin/stage2-post-reboot.sh
          scp -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no /tmp/stage2-env.sh root@"$SVC_SERVER_IP":/opt/stage2-env.sh
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@"$SVC_SERVER_IP" "chmod +x /usr/local/bin/stage2-post-reboot.sh && chmod 600 /opt/stage2-env.sh"

          echo "ðŸ—ï¸ Executing Stage 1 on server..."
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@"$SVC_SERVER_IP" "bash /root/stage1-setup.sh || true"

          echo "ðŸ” Rebooting server to trigger Stage 2..."
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@"$SVC_SERVER_IP" "reboot" || true

          echo "â³ Waiting for server to come back after reboot..."
          chmod +x ./scripts/linode/wait-for-ssh.sh
          ./scripts/linode/wait-for-ssh.sh "$SVC_SERVER_IP"

          # Install deployment key for subsequent steps
          mkdir -p ~/.ssh
          cp "$HOME/.ssh/linode_deployment_key" ~/.ssh/deployment_key
          chmod 600 ~/.ssh/deployment_key

          echo "ðŸš€ Deploying service after Stage 2..."
          chmod +x ./scripts/deployment/deploy-service.sh
          ./scripts/deployment/deploy-service.sh "${SVC_NAME}" "${SVC_SERVER_IP}"
          echo "status=success" >> $GITHUB_OUTPUT
  service-restart:
    name: ðŸ”„ Service Restart
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [stage0-preflight, infrastructure]
    if: |
      inputs.action_type == 'restart' &&
      needs.infrastructure.result == 'success'
    outputs:
      status: ${{ steps.restart.outputs.status }}
    steps:
      - name: ðŸ“ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      - name:  Download SSH key artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment_key
          path: /tmp/key
      - name: ðŸ” Install SSH key
        run: |
          mkdir -p ~/.ssh
          cp /tmp/key/linode_deployment_key ~/.ssh/deployment_key
          chmod 600 ~/.ssh/deployment_key
      - name: ðŸ”„ Restart Service
        id: restart
        env:
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
        run: |
          echo "ðŸ”„ Restarting ${{ env.SERVICE_NAME }} service..."
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP "
            if [[ '${{ env.SOURCE_REPOSITORY }}' != '${{ env.SERVICE_NAME }}' ]]; then
              REPO_DIR='${{ env.SOURCE_REPOSITORY }}'
            else
              REPO_DIR='${{ env.SERVICE_NAME }}'
            fi
            cd /home/${{ env.SERVICE_NAME }}_user/\$REPO_DIR
            if [[ -f 'docker-compose.yml' ]]; then
              docker-compose restart
            elif [[ '${{ env.SERVICE_NAME }}' =~ ^fks- ]]; then
              SERVICE_TYPE='${SERVICE_NAME#fks-}'
              if [[ -f \"docker-compose.\$SERVICE_TYPE.yml\" ]]; then
                docker-compose -f \"docker-compose.\$SERVICE_TYPE.yml\" restart
              else
                exit 1
              fi
            elif systemctl list-units --type=service | grep -q '${{ env.SERVICE_NAME }}'; then
              systemctl restart ${{ env.SERVICE_NAME }}
            elif [[ -f 'start.sh' ]]; then
              pkill -f '${{ env.SERVICE_NAME }}' || true
              sleep 5
              su - ${{ env.SERVICE_NAME }}_user -c 'cd /home/${{ env.SERVICE_NAME }}_user/${{ env.SERVICE_NAME }} && ./start.sh'
            else
              exit 1
            fi
            echo 'âœ… Service restart completed'
          "
          echo "status=success" >> $GITHUB_OUTPUT
  service-destroy:
    name: ðŸ’¥ Service Destroy
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [stage0-preflight]
    if: |
      needs.stage0-preflight.outputs.should_destroy == 'true' &&
      inputs.action_type == 'destroy'
    outputs:
      status: ${{ steps.destroy.outputs.status }}
    steps:
      - name: ðŸ“ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      - name: ðŸ’¥ Destroy Service Infrastructure
        id: destroy
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
        run: |
          pip install linode-cli
          export LINODE_CLI_TOKEN="${{ secrets.LINODE_CLI_TOKEN }}"
          echo "ðŸ’¥ Destroying service infrastructure for ${{ env.SERVICE_NAME }}..."
          SERVER_LABEL="${{ env.SERVICE_NAME }}"
          SERVER_INFO=$(linode-cli linodes list --text --no-headers | grep -E "^[0-9]+\s+$SERVER_LABEL(\s|-[0-9]+\s)" || true)
          if [[ -n "$SERVER_INFO" ]]; then
            echo "$SERVER_INFO" | while read -r server_line; do
              if [[ -n "$server_line" ]]; then
                SERVER_ID=$(echo "$server_line" | cut -f1)
                linode-cli linodes delete "$SERVER_ID" || true
              fi
            done
          else
            echo "â„¹ï¸ No server found with label pattern: $SERVER_LABEL"
          fi
          echo "ðŸ”— Cleaning up Tailscale devices..."
          if [[ -n "${TS_OAUTH_CLIENT_ID:-}" && -n "${TS_OAUTH_SECRET:-}" ]]; then
            chmod +x ./scripts/cleanup/cleanup-resources.sh
            export TS_OAUTH_CLIENT_ID TS_OAUTH_SECRET TAILSCALE_TAILNET
            ./scripts/cleanup/cleanup-resources.sh "${{ env.SERVICE_NAME }}" || true
          fi
          echo "ðŸŒ Cleaning up DNS records..."
          chmod +x ./scripts/dns/cloudflare-updater.sh
          ./scripts/dns/cloudflare-updater.sh update-service \
            --service "${{ env.SERVICE_NAME }}" \
            --ip "127.0.0.1" \
            --domain "${{ inputs.domain_suffix }}" \
            --token "$CLOUDFLARE_API_TOKEN" \
            --zone-id "$CLOUDFLARE_ZONE_ID" || true
          echo "status=success" >> $GITHUB_OUTPUT
  health-check:
    name: ðŸ¥ Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [infrastructure]
    if: |
      always() &&
      needs.infrastructure.result == 'success' &&
      inputs.action_type == 'health-check'
    steps:
      - name: ðŸ“ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      - name: ðŸ“¥ Download SSH key artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment_key
          path: /tmp/key
      - name: ðŸ” Install SSH key
        run: |
          mkdir -p ~/.ssh
          cp /tmp/key/linode_deployment_key ~/.ssh/deployment_key
          chmod 600 ~/.ssh/deployment_key
      - name: ðŸ¥ Run Health Checks
        env:
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
          TAILSCALE_IP: ${{ needs.infrastructure.outputs.tailscale_ip }}
        run: |
          if [[ -n "$SERVER_IP" ]]; then
            chmod +x ./scripts/health/service-health-check.sh
            ./scripts/health/service-health-check.sh \
              "${{ env.SERVICE_NAME }}" \
              "$SERVER_IP" \
              "$TAILSCALE_IP"
          fi
  post-deploy-health:
    name: ðŸ¥ Post-Deploy Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [infrastructure]
    if: |
      always() &&
      inputs.action_type == 'deploy' &&
      needs.infrastructure.result == 'success'
    steps:
      - name: ðŸ“ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      - name: ðŸ“¥ Download SSH key artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment_key
          path: /tmp/key
      - name: ðŸ” Install SSH key
        run: |
          mkdir -p ~/.ssh
          cp /tmp/key/linode_deployment_key ~/.ssh/deployment_key
          chmod 600 ~/.ssh/deployment_key
      - name: ðŸ¥ Run Post-Deploy Health Checks
        env:
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
          TAILSCALE_IP: ${{ needs.infrastructure.outputs.tailscale_ip }}
        run: |
          if [[ -n "$SERVER_IP" ]]; then
            chmod +x ./scripts/health/service-health-check.sh
            ./scripts/health/service-health-check.sh \
              "${{ env.SERVICE_NAME }}" \
              "$SERVER_IP" \
              "$TAILSCALE_IP"
          fi
  summary:
    name: ðŸ“‹ Summary
    runs-on: ubuntu-latest
    needs: [stage0-preflight, infrastructure, service-restart, service-destroy, health-check, post-deploy-health]
    if: always()
    steps:
      - name: ðŸ“‹ Deployment Summary
        run: |
          echo "ðŸ“‹ Deployment Summary for ${{ env.SERVICE_NAME }}"
          echo "=================================================="
          echo "ðŸŽ¯ Action: ${{ env.ACTION_TYPE }}"
          echo "ðŸ–¥ï¸ Server Type: ${{ inputs.server_type }}"
          echo "ðŸŒ Region: ${{ inputs.target_region }}"
          echo "ðŸ”— Domain: ${{ env.FULL_DOMAIN }}"
          echo ""
          echo "ðŸ“Š Job Job Results:"
          echo "âœ… Preflight: ${{ needs.stage0-preflight.result }}"
          echo "ðŸ—ï¸ Infrastructure: ${{ needs.infrastructure.result }}"
          echo "ðŸš€ Deploy: ${{ needs.infrastructure.result }}"
          echo "ðŸ”„ Service Restart: ${{ needs.service-restart.result }}"
          echo "ðŸ’¥ Service Destroy: ${{ needs.service-destroy.result }}"
          echo "ðŸ¥ Health Check: ${{ needs.health-check.result }}"
          echo "ðŸ¥ Post-Deploy Health: ${{ needs.post-deploy-health.result }}"
          if [[ "${{ needs.infrastructure.outputs.server_ip }}" ]]; then
            echo ""
            echo "ðŸ–¥ï¸ Server Details:"
            echo "   ðŸ“ Public IP: ${{ needs.infrastructure.outputs.server_ip }}"
            echo "   ðŸ”— Tailscale IP: ${{ needs.infrastructure.outputs.tailscale_ip }}"
            echo "   ðŸ†” Server ID: ${{ needs.infrastructure.outputs.server_id }}"
          fi
          if [[ "${{ needs.infrastructure.result }}" == "success" ]]; then
            echo ""
            echo "ðŸŽ‰ Overall Status: SUCCESS"
            echo "âœ… ${{ env.SERVICE_NAME }} deployment completed!"
          elif [[ "${{ needs.service-restart.result }}" == "success" ]]; then
            echo ""
            echo "ðŸŽ‰ Overall Status: SUCCESS"
            echo "ðŸ”„ ${{ env.SERVICE_NAME }} restart completed!"
          elif [[ "${{ needs.service-destroy.result }}" == "success" ]]; then
            echo ""
            echo "ðŸŽ‰ Overall Status: SUCCESS"
            echo "ðŸ’¥ ${{ env.SERVICE_NAME }} destruction completed!"
          else
            echo ""
            echo "âŒ Overall Status: FAILED"
            echo "ðŸ’¥ Check job logs for details"
          fi
      - name: ðŸ“¢ Send Discord Notification
        if: always()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          ACTION_TYPE: ${{ inputs.action_type || 'deploy' }}
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
          TAILSCALE_IP: ${{ needs.infrastructure.outputs.tailscale_ip }}
          SERVER_ID: ${{ needs.infrastructure.outputs.server_id }}
          INFRA_RESULT: ${{ needs.infrastructure.result }}
          RESTART_RESULT: ${{ needs.service-restart.result }}
          DESTROY_RESULT: ${{ needs.service-destroy.result }}
          HEALTH_RESULT: ${{ needs.health-check.result }}
          POST_HEALTH_RESULT: ${{ needs.post-deploy-health.result }}
        run: |
          echo "ðŸ“¢ Sending Discord notification via script..."
          sudo apt-get update -y >/dev/null
          sudo apt-get install -y jq >/dev/null
          chmod +x ./scripts/notifications/notify-discord.sh || true
          ./scripts/notifications/notify-discord.sh || true
